{"./":{"url":"./","title":"Introduction","keywords":"","body":"欢迎使用 csingo 框架 本文档仅用于介绍 csingo 框架的使用方法，不作其他任何用途。 csingo 是基于 gin 框架开发的一个企业级 HTTP 微服务golang框架。其中保留了部分 php 的编程习惯，以及 php 中的 laravel 框架的开发习惯，旨在 phper 能够快速熟悉 golang "},"csingo/1 前言/1.1 项目介绍.html":{"url":"csingo/1 前言/1.1 项目介绍.html","title":"1.1 项目介绍","keywords":"","body":"项目介绍 设计思想 迎合主流 php 框架，针对 laravel 和 hyperf，便于 phper 转型 融入 DDD 设计思想，增加多应用概念，区分应用领域和服务领域 使用代码生成工具，降低框架学习成本和使用成本 版本依赖 golang >= 1.17 gin >= v1.8.1 protoc-gen-go = v1.27.1 protoc = v3.19.1 目录结构及说明 . ├── Makefile // make工具配置文件 ├── app // 应用目录 │ └── demo // demo 应用目录 │ ├── command // 任务命令目录 │ │ └── HelloCommand.go │ ├── controller // 控制器目录 │ │ └── HelloController.go │ ├── domain // 领域服务目录 │ │ └── HelloDomain.go │ ├── middleware // 中间件目录 │ │ └── HelloMiddleware.go │ ├── model // 数据模型目录 │ │ └── Hello.go │ ├── repository // 数据仓库目录 │ │ └── HelloRepository.go │ ├── service // 应用服务目录 │ │ └── HelloService.go │ └── validator // 验证器目录 │ └── HelloValidator.go ├── autoload // 自动加载目录, 该目录的文件用于框架启动预加载，不建议手动修改其中内容 │ ├── Command.go │ ├── Config.go │ ├── Controller.go │ ├── Domain.go │ ├── Loader.go │ ├── Middleware.go │ ├── Service.go │ └── Validator.go ├── base // 应用基础结构定义目录，存放由proto生成的相关文件，不建议手动修改其中内容 │ └── demo │ ├── HelloService.pb.go │ ├── HelloServiceHttpClient.go │ ├── HelloServiceHttpServer.go │ └── Message.pb.go ├── bin // 执行文件编译目录 ├── config // 配置目录 │ ├── typs // 配置定义目录 │ └── vars // 配置实例化目录 │ ├── CommandConf.go │ ├── ConfigCenterConf.go │ ├── DatabaseConf.go │ ├── LogConf.go │ ├── RouteConf.go │ ├── RpcConf.go │ └── ServerConf.go ├── docker // 容器部署目录 │ └── Dockerfile ├── global // 全局参数定义目录 ├── go.mod ├── go.sum ├── proto // proto文件目录 │ └── demo │ ├── enum.proto // 定义应用常量 │ ├── error.proto // 定义应用异常常量 │ ├── HelloService.proto // 定义应用服务 │ └── Message.proto // 定义应用相关实体 └── server // 程序入口 └── main.go 目录概览 编码目录 app, 应用代码目录 config, 配置代码目录 global, 全局参数代码目录 proto, proto代码目录 自动生成代码目录 autoload, 自动加载目录 base, 应用基础结构定义目录 server, 程序入口目录 "},"csingo/1 前言/1.2 编程须知.html":{"url":"csingo/1 前言/1.2 编程须知.html","title":"1.2 编程须知","keywords":"","body":"编程须知 编程建议 变量等命名规则遵循驼峰格式，若需要被引用则首字母也需要大写 尽量按单一职责区分文件，即定义声明和实例化分开两个文件，在config目录中，typs文件夹用于定义配置，vars目录用于实例化配置 全局变量尽量在global中定义，且只会被应用，不引用其他项目内的包 尽量使用工具生成文件，否则容易产生忽略autoload目录中的自动生成代码，等各种问题 文件命名尽量带上职责功能后缀，比如：xxxController, xxxValidator, xxxRepository, xxxConf ...... 注意事项 框架封装的组件库尚未完善，若要引用第三方组件库，可在项目根目录新建目录进行组件初始化操作 "},"csingo/1 前言/1.3 性能压测.html":{"url":"csingo/1 前言/1.3 性能压测.html","title":"1.3 性能压测","keywords":"","body":""},"csingo/2 快速入门/2.1 安装.html":{"url":"csingo/2 快速入门/2.1 安装.html","title":"2.1 安装","keywords":"","body":"安装 安装golang环境 参考 golang 官方文档 使用框架工具 配置环境变量 export PATH=$PATH:$GOROOT/bin go env -w GO111MODULE=on go env -w GOPROXY=https://goproxy.cn,direct 安装工具 go install gitee.com/csingo/csingo@v0.0.44 // 当前最新版本 v0.0.44 // 查看当前版本 csingo version::show // 更新工具 csingo version::update // 初始化工具，安装proto相关工具 csingo tool::init // 查看帮助信息 csingo 创建项目 csingo project::create --name=demo 创建项目相关文件 参考工具帮助信息 csingo help::doc 复制example代码 example 代码地址 "},"csingo/2 快速入门/2.2 启动.html":{"url":"csingo/2 快速入门/2.2 启动.html","title":"2.2 启动","keywords":"","body":"启动 启动和打包指令必须在项目根目录内执行 go 指令启动 go run server/main.go make 指令启动 可根据需要自定义Makefile内容 make run csingo 指令启动 // 方式一，直接启动 csingo server::start // 方式二，热启动 csingo server::watch 打包程序 // 方式一 go build -o bin/runner server/main.go // 方式二 make build "},"csingo/2 快速入门/2.3 配置.html":{"url":"csingo/2 快速入门/2.3 配置.html","title":"2.3 配置","keywords":"","body":"配置 框架中的配置，统一在 config 目录 内的 typs 目录 进行定义以及在 vars 目录 进行实例化。且所有配置都应在 autoload 目录中提前注入容器，以便程序读取使用 config 配置目录&文件说明 只对默认配置进行说明 typs 配置定义目录，用于开发者自定义配置，框架配置已在各个功能包中定义，无需重复定义 vars 配置实例化目录，用于开发者实例化配置 vars/ConfigCenterConf.go 配置中心配置，目前只支持 file 和 nacos 两种类型driver vars/CommandConf.go 任务指令配置 vars/DatabaseConf.go 数据库配置 vars/LogConf.go 日志配置 vars/RouteConf.go 路由配置 vars/RpcConf.go rpc配置 vars/ServerConf.go 应用服务配置 ServerConf 说明 package vars import \"gitee.com/csingo/cServer\" var ServerConfig = &cServer.ServerConf{ HttpServer: &cServer.ServerConf_HttpServer{ Enable: true, // 是否启用HTTP Port: 8080, // 服务端口 ReadTimeout: 10, // 读超时，单位秒 WriteTimeout: 10, // 写超时，单位秒 ExitTimeout: 10, // 请求超时，单位秒 MaxHeaderBytes: 20, // 请求头大小，偏移量，1 自定义配置 csingo 创建配置 csingo config::create --name=TestConf 手动创建配置 config/typs 目录创建 TestConf.go 文件，定义配置具体结构 package typs // TestConf 自定义配置结构体 type TestConf {} // ConfigName 继承 cConfig.ConfigInterface，用于读取配置 func (i *TestConf) ConfigName() string { return \"TestConf\" } config/vars 目录创建 TestConf.go 文件，实例化配置 package vars import ( \"demo/config/typs\" ) var TestConfig = &typs.TestConf{} autoload/Config.go 文件添加容器注入 package autoload import ( \"demo/config/vars\" \"gitee.com/csingo/cServer\" ) func InjectConf() { cServer.Inject(vars.LogConfig) cServer.Inject(vars.ConfigCenterConfig) cServer.Inject(vars.DatabaseConfig) cServer.Inject(vars.CommandConfig) cServer.Inject(vars.RouteConfig) cServer.Inject(vars.RpcConfig) cServer.Inject(vars.ServerConfig) cServer.Inject(vars.TestConfig) } "},"csingo/2 快速入门/2.4 容器注入.html":{"url":"csingo/2 快速入门/2.4 容器注入.html","title":"2.4 容器注入","keywords":"","body":"容器注入 在 csingo 框架中引入了 容器注入 的概念，在程序启动时会实例化 ApplicationContainer struct，定义一个全局的容器变量 app。 在 app 变量中，存储了所有注入的变量，以此实现单例模式。 框架中的 Controller, Service, Domain, Middleware, Command, Validator, Config 都已经在 autoload 中实现了注入，只需要开发者使用 csingo 工具进行文件创建。 autoload 目录&文件说明 Loader.go 全局加载器，用于引入各模块自动加载方法调用 Command.go 任务命令加载器，加载所有应用的Command Config.go 配置加载器，加载config目录中的配置 Controller.go 控制器加载器，加载所有应用的Controller Validator.go 验证器加载器，加载所有应用的Validator Middleware.go 中间件加载器，加载所有应用的Middleware Service.go 应用服务加载器，加载所有应用的Service Domain.go 领域服务加载器，加载所有应用的Domain 自定义自动加载变量 在 autoload 文件夹内新增自定义的自动加载器，如：Test.go 在新增的自动加载器定义自动加载方法，并注入自定义变量 xxx.Y package autoload import ( \"demo/xxx\" \"gitee.com/csingo/cServer\" ) func InjectTest() { cServer.Inject(xxx.Y) } 注入 & 获取 注入 import \"gitee.com/csingo/cServer\" cServer.Inject(xxx) 获取 注入的变量，假设注入的变量位于包 xxx/yyy 中，且struct名为 zzz。即以“包名 + / + 结构体名”为标识符进行变量获取 import \"gitee.com/csingo/cServer\" cServer.GetInstance(\"xxx/yyy/zzz\") 实现细节 package cServer type ServerContainer struct { Lock *sync.Mutex Instances map[string]interface{} } func (i *ServerContainer) Save(instance interface{}) { i.Lock.Lock() defer i.Lock.Unlock() name := reflect.TypeOf(instance).Elem().Name() path := reflect.TypeOf(instance).Elem().PkgPath() index := path + \"/\" + name if i.Instances == nil { i.Instances = make(map[string]interface{}) } i.Instances[index] = instance } func (i *ServerContainer) Get(index string) interface{} { i.Lock.Lock() defer i.Lock.Unlock() if _, ok := i.Instances[index]; ok { return i.Instances[index] } else { return nil } } func Inject(instance interface{}) { container.Save(instance) } func GetInstance(index string) interface{} { return container.Get(index) } "},"csingo/2 快速入门/2.5 协程上下文.html":{"url":"csingo/2 快速入门/2.5 协程上下文.html","title":"2.5 协程上下文","keywords":"","body":""},"csingo/3 基础功能/3.1 路由.html":{"url":"csingo/3 基础功能/3.1 路由.html","title":"3.1 路由","keywords":"","body":"路由 路由配置位于 config/RouteConf.go 文件中 路由配置的定义在 cServer.RouteConf 配置说明 package vars import ( \"gitee.com/csingo/cServer\" ) var RouteConfig = &cServer.RouteConf{ Middlewares: &cServer.RouteConf_Middlewares{ Prefix: []*cServer.RouteConf_Middleware{ {App: \"demo\", Name: \"HelloMiddleware\"}, }, Surfix: []*cServer.RouteConf_Middleware{}, }, Routes: []*cServer.RouteConf{ {Path: \"/rpc/call\", Method: \"POST\", App: \"csingo\", Controller: \"RpcController\", Function: \"Handler\"}, {Path: \"/ping\", Method: \"GET\", App: \"demo\", Controller: \"HelloController\", Function: \"Ping\"}, }, } 路由支持无限层级的嵌套，相应的 uri 和 middleware 也会进行嵌套 中间件区分前置中间件和后置中间件 目前只支持单一的请求方式，不支持 GET 和 POST 同时接收，需要同时接收则定义不同Method的两个路由 "},"csingo/3 基础功能/3.2 控制器.html":{"url":"csingo/3 基础功能/3.2 控制器.html","title":"3.2 控制器","keywords":"","body":"控制器 创建控制器 在 app/demo/controller 目录创建 TestController.go csingo app::controller --app=demo --name=TestController "},"csingo/3 基础功能/3.3 验证器.html":{"url":"csingo/3 基础功能/3.3 验证器.html","title":"3.3 验证器","keywords":"","body":"验证器 创建验证器 在 app/demo/validator 目录创建 TestValidator.go csingo app::validator --app=demo --name=TestValidator 使用例子 package cValidator import ( \"gitee.com/csingo/cValidator/rules\" \"log\" \"testing\" ) type A struct { AAA string `json:\"aaa\"` BB *B `json:\"bb\"` } type B struct { BBB string `json:\"bbb\"` CC *C `json:\"cc\"` } type C struct { CCC string `json:\"ccc\"` DD []*D `json:\"dd\"` } type D struct { DDD string `json:\"ddd\"` AA *A `json:\"aa\"` } var o = map[string]*A{ \"m\": &A{ AAA: \"oa\", BB: &B{ BBB: \"ob\", CC: &C{ CCC: \"oc\", DD: []*D{ &D{DDD: \"od1\"}, &D{DDD: \"od2\"}, }, }, }, }, } type TestValidator struct{} func (i *TestValidator) ValidatorName() (app, name string) { return \"test\", \"TestValidator\" } func (i *TestValidator) Rules() map[string][]*rules.ValidatorRules { return map[string][]*rules.ValidatorRules{ \"test\": { { Field: \"m.BB.CC.DD.*.DDD\", Rules: []*rules.ValidatorRule{{Name: \"required\", Message: \"必须\"}}, }, }, } } func TestInject(t *testing.T) { Load() Inject(&TestValidator{}) err := Validate([]*Validator{ {App: \"test\", Name: \"TestValidator\", Scene: \"test\"}, }, o) log.Println(err) } 规则列表 required "},"csingo/3 基础功能/3.4 中间件.html":{"url":"csingo/3 基础功能/3.4 中间件.html","title":"3.4 中间件","keywords":"","body":"中间件 类型 前置中间件, 在调用 controller 前调用 后置中间件，在调用 controller 后调用 创建中间件 在 app/demo/middleware 目录创建 TestMiddleware.go csingo app::middleware --app=demo --name=TestMiddleware "},"csingo/3 基础功能/3.5 应用服务.html":{"url":"csingo/3 基础功能/3.5 应用服务.html","title":"3.5 应用服务","keywords":"","body":"应用服务 借鉴 DDD 领域驱动设计，独立出一层应用服务。用于应用服务相互调用，以及调用本领域的领域服务。跨领域调用，只能经过应用服务进行。 功能说明 service 中可调用其他 app 的 service，本 app 的 repository / model 。 service 可被 controller 和 command 中调用。 service 应该由 proto 生成，因为在其他程序中调用时，需要使用 proto 生成 sdk 由 proto 生成的 service 方法，只会不断叠加，不会进行删减 创建步骤 定义 proto 建议 service 定义 和 message 定义区分开单独的两个文件 建议每个 service 单独一个 proto 文件 HelloService.proto syntax = \"proto3\"; option go_package = \"../demo\"; package demo; import \"demo/Message.proto\"; service HelloService { rpc Hello(HelloServiceHelloReq) returns (HelloServiceHelloRsp); } Message.proto syntax = \"proto3\"; option go_package = \"../demo\"; package demo; message HelloServiceHelloReq { string name = 1; } message HelloServiceHelloRsp { string name = 1; } 生成 service csingo app::service --app=demo [--protoPath=] 执行指令后，在 base/demo 生成相关sdk，在 app/demo/service 生成 HelloService.go，在 autoload/Service.go 注入 HelloServiceHTTPServer 。 sdk目录结构 base/demo ├── HelloService.pb.go // proto 生成的service定义文件 ├── HelloServiceHttpClient.go // 框架自动生成的sdk客户端 ├── HelloServiceHttpServer.go // 框架自定生成的HTTP服务端 └── Message.pb.go // proto 生成的message定义文件 app/demo/service/HelloService.go package service import ( \"example/base/demo\" \"github.com/gin-gonic/gin\" ) type HelloService struct { demo.HelloServiceHTTPServer } func (i *HelloService) Hello(ctx *gin.Context, req *demo.HelloServiceHelloReq) (rsp *demo.HelloServiceHelloRsp, err error) { return nil, nil } autoload/Service.go package autoload import ( \"gitee.com/csingo/cServer\" DemoServices \"example/app/demo/service\" ) func InjectService() { cServer.Inject(&DemoServices.HelloService{}) } 调用 service package controller import ( \"example/app/demo/service\" \"example/base/demo\" \"github.com/gin-gonic/gin\" ) type HelloController struct{} func (i *HelloController) ControllerName() (app, name string) { return \"demo\", \"HelloController\" } func (i *HelloController) Say(ctx *gin.Context) (int, interface{}) { rsp, _ := (&service.HelloService{}).Hello(ctx, &demo.HelloServiceHelloReq{Name: \"cxy\"}) return 0, rsp } "},"csingo/3 基础功能/3.6 领域服务.html":{"url":"csingo/3 基础功能/3.6 领域服务.html","title":"3.6 领域服务","keywords":"","body":"领域服务 创建领域服务 在 app/demo/domain 目录创建 TestDomain.go csingo app::domain --app=demo --name=TestDomain "},"csingo/3 基础功能/3.7 数据仓库.html":{"url":"csingo/3 基础功能/3.7 数据仓库.html","title":"3.7 数据仓库","keywords":"","body":"数据仓库 创建数据仓库 在 app/demo/repository 目录创建 TestRepository.go csingo app::repository --app=demo --name=TestRepository "},"csingo/3 基础功能/3.8 模型.html":{"url":"csingo/3 基础功能/3.8 模型.html","title":"3.8 模型","keywords":"","body":"模型 "},"csingo/3 基础功能/3.9 任务命令.html":{"url":"csingo/3 基础功能/3.9 任务命令.html","title":"3.9 任务命令","keywords":"","body":"任务命令 任务命令会在应用启动时先于 HTTP 服务启动，可设置常驻任务和定时任务。 可执行应用的初始化操作，队列操作等等 任务执行已做了panic捕获处理，一般情况下，任务执行panic不应该导致程序终止运行 任务命令类型 定时任务 常驻任务 任务命令模式 异步串行模式 异步并行模式 同步阻塞模式（未实现） 创建任务命令 在 app/demo/command 目录添加 TestCommand.go csingo app::command --app=demo --name=TestCommand 配置任务命令 配置内容 package vars import \"gitee.com/csingo/cCommand\" var CommandConfig = &cCommand.CommandConf{ Enable: true, Commands: []*cCommand.CommandConf_Command{ {Mode: cCommand.CommandMode_Single, Wait: 0, Try: 1, Cron: \"* * * * * *\", App: \"demo\", Command: \"HelloCommand\", Method: \"Say\", Options: []string{\"cxy\"}}, }, } 参数说明 Mode 任务模式cCommand.CommandMode_Single 异步串行模式cCommand.CommandMode_Multi 异步并行模式 Wait 延时时长，单位秒。等待一定时间后开始执行。注意是不会阻塞其他任务和服务的 Try 执行次数。try > 0 时，Cron 配置不生效，执行完指定次数后会自动销毁任务 Cron 定时配置，参考linux中的crontab，可精确到秒。当 Try = 0 时，该配置有效 App 指定应用文件夹 Command 指定执行的Command Method 指定执行的方法 Options 指定执行方法的参数，注意严格按照方法定义的参数顺序进行传参 "},"csingo/3 基础功能/3.10 请求.html":{"url":"csingo/3 基础功能/3.10 请求.html","title":"3.10 请求","keywords":"","body":"请求 "},"csingo/3 基础功能/3.11 响应.html":{"url":"csingo/3 基础功能/3.11 响应.html","title":"3.11 响应","keywords":"","body":"响应 "},"csingo/3 基础功能/3.12 异常.html":{"url":"csingo/3 基础功能/3.12 异常.html","title":"3.12 异常","keywords":"","body":"异常 "},"csingo/3 基础功能/3.13 日志.html":{"url":"csingo/3 基础功能/3.13 日志.html","title":"3.13 日志","keywords":"","body":"日志 "},"csingo/4 组件库/4.1 配置中心.html":{"url":"csingo/4 组件库/4.1 配置中心.html","title":"4.1 配置中心","keywords":"","body":""},"csingo/4 组件库/4.2 Proto.html":{"url":"csingo/4 组件库/4.2 Proto.html","title":"4.2 Proto","keywords":"","body":""},"csingo/4 组件库/4.3 Redis.html":{"url":"csingo/4 组件库/4.3 Redis.html","title":"4.3 Redis","keywords":"","body":""},"csingo/4 组件库/4.4 Kafka.html":{"url":"csingo/4 组件库/4.4 Kafka.html","title":"4.4 Kafka","keywords":"","body":""},"csingo/5 微服务/5.1 HTTP-RPC.html":{"url":"csingo/5 微服务/5.1 HTTP-RPC.html","title":"5.1 HTTP RPC","keywords":"","body":""},"csingo/5 微服务/5.2 应用SDK.html":{"url":"csingo/5 微服务/5.2 应用SDK.html","title":"5.2 应用SDK","keywords":"","body":""}}