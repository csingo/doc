{"./":{"url":"./","title":"Introduction","keywords":"","body":"Introduction "},"csingo/1 前言/1.1 项目介绍.html":{"url":"csingo/1 前言/1.1 项目介绍.html","title":"1.1 项目介绍","keywords":"","body":"项目介绍 1. 设计思想 迎合主流 php 框架，针对 laravel 和 hyperf，便于 phper 转型 融入 DDD 设计思想，增加多应用概念，区分应用领域和服务领域 使用代码生成工具，降低框架学习成本和使用成本 2. 版本依赖 golang >= 1.17 gin >= v1.8.1 protoc-gen-go = v1.27.1 protoc = v3.19.1 3. 目录结构及说明 . ├── Makefile // make工具配置文件 ├── app // 应用目录 │ └── demo // demo 应用目录 │ ├── command // 任务命令目录 │ │ └── HelloCommand.go │ ├── controller // 控制器目录 │ │ └── HelloController.go │ ├── domain // 领域服务目录 │ │ └── HelloDomain.go │ ├── middleware // 中间件目录 │ │ └── HelloMiddleware.go │ ├── model // 数据模型目录 │ │ └── Hello.go │ ├── service // 应用服务目录 │ │ └── HelloService.go │ └── validator // 验证器目录 │ └── HelloValidator.go ├── autoload // 自动加载目录, 该目录的文件用于框架启动预加载，不建议手动修改其中内容 │ ├── Command.go │ ├── Config.go │ ├── Controller.go │ ├── Domain.go │ ├── Loader.go │ ├── Middleware.go │ ├── Service.go │ └── Validator.go ├── base // 应用基础结构定义目录，存放由proto生成的相关文件，不建议手动修改其中内容 │ └── demo │ ├── HelloService.pb.go │ ├── HelloServiceHttpClient.go │ ├── HelloServiceHttpServer.go │ └── Message.pb.go ├── bin // 执行文件编译目录 ├── config // 配置目录 │ ├── typs // 配置定义目录 │ └── vars // 配置实例化目录 │ ├── CommandConf.go │ ├── ConfigCenterConf.go │ ├── DatabaseConf.go │ ├── LogConf.go │ ├── RouteConf.go │ ├── RpcConf.go │ └── ServerConf.go ├── docker // 容器部署目录 │ └── Dockerfile ├── global // 全局参数定义目录 ├── go.mod ├── go.sum ├── proto // proto文件目录 │ └── demo │ ├── enum.proto // 定义应用常量 │ ├── error.proto // 定义应用异常常量 │ ├── HelloService.proto // 定义应用服务 │ └── Message.proto // 定义应用相关实体 └── server // 程序入口 └── main.go 4. 目录概览 4.1 编码目录 app, 应用代码目录 config, 配置代码目录 global, 全局参数代码目录 proto, proto代码目录 4.2.自动生成代码目录 autoload, 自动加载目录 base, 应用基础结构定义目录 server, 程序入口目录 "},"csingo/1 前言/1.2 编程须知.html":{"url":"csingo/1 前言/1.2 编程须知.html","title":"1.2 编程须知","keywords":"","body":"编程须知 1. 编程建议 变量等命名规则遵循驼峰格式，若需要被引用则首字母也需要大写 尽量按单一职责区分文件，即定义声明和实例化分开两个文件，在config目录中，typs文件夹用于定义配置，vars目录用于实例化配置 全局变量尽量在global中定义，且只会被其他目录引用，不引用其他其他目录 尽量使用工具生成文件，否则容易产生忽略autoload目录中的自动生成代码，等各种问题 文件命名尽量带上职责功能后缀，比如：xxxController, xxxValidator, xxxService, xxxDomain, xxxConf ...... 2. 注意事项 框架封装的组件库尚未完善，若要引用第三方组件库，可在项目根目录新建目录进行组件初始化操作 "},"csingo/1 前言/1.3 性能压测.html":{"url":"csingo/1 前言/1.3 性能压测.html","title":"1.3 性能压测","keywords":"","body":""},"csingo/1 前言/1.4 版本更新.html":{"url":"csingo/1 前言/1.4 版本更新.html","title":"1.4 版本更新","keywords":"","body":"版本更新 1. 待实现功能 路由动态加载 配置中心接入 Redis 客户端 配置中心接入 ETCD 客户端 2. 时间线 "},"csingo/2 快速入门/2.1 安装.html":{"url":"csingo/2 快速入门/2.1 安装.html","title":"2.1 安装","keywords":"","body":"安装 1. 安装golang环境 参考 golang 官方文档 2. 使用框架工具 2.1 配置环境变量 export PATH=$PATH:$GOROOT/bin go env -w GO111MODULE=on go env -w GOPROXY=https://goproxy.cn,direct 2.2 安装工具 go install gitee.com/csingo/csingo@v0.0.44 // 当前最新版本 v0.0.44 // 查看当前版本 csingo version::show // 更新工具 csingo version::update // 初始化工具，安装proto相关工具 csingo tool::init // 查看帮助信息 csingo 2.3 创建项目 csingo project::create --name=demo 2.4 创建项目相关文件 参考工具帮助信息 csingo help::doc "},"csingo/2 快速入门/2.2 启动 & 打包.html":{"url":"csingo/2 快速入门/2.2 启动 & 打包.html","title":"2.2 启动 & 打包","keywords":"","body":"启动 & 打包 1. 程序入口文件 server/main.go 是整个应用程序的入口文件 启动和打包指令必须在项目根目录内执行 2. go 指令 go run server/main.go go build server/main.go 3. make 指令 make指令要求先在系统中安装工具包，ubuntu系统安装如下： apt-get install -y make 在创建项目时 Makefile 已经默认在项目根目录中创建，具体内容如下： build: go build -o bin/example server/main.go run: go run server/main.go push: git add . git commit -m \"update\" git push 其中包含了 make build, make run, make push 三个指令，若有需要可自定义指令 make build: 打包程序，打包后的二进制执行文件位于 bin 目录中 make run: 直接运行程序，实际上使用了 go run 指令启动 make push: 推送代码，当需要提交代码时，若不需要修改提交说明，可执行指令完成 git 操作 4. csingo 指令 csingo 框架封装了启动程序的指令，可使用工具命令启动程序。其原理是在工具中调用系统shell，执行 go 相关指令。 csingo 启动程序包含了两种模式：直接启动，热启动 4.1 直接启动 实际上使用了 go run 指令启动 csingo server::start 4.2 热启动 在创建项目时，项目根目录中包含了 .watch 文件，该文件定义了需要监听的目录和文件，当这些文件发生内容变动，会触发工具终止程序运行，并重新启动程序 csingo server::watch "},"csingo/2 快速入门/2.3 配置.html":{"url":"csingo/2 快速入门/2.3 配置.html","title":"2.3 配置","keywords":"","body":"配置 框架中的配置，统一在 config 目录 内的 typs 目录 进行定义以及在 vars 目录 进行实例化。 且所有配置都应在 autoload 目录中提前注入容器，以便程序读取使用 1. config 配置目录&文件说明 只对默认配置进行说明，注意内置的配置只有在程序启动时才会进行加载，所以这些配置的变动，只有重启才会生效。 如果希望内置配置实时生效，则需要自定义配置的实时监听逻辑，且并非所有配置都适合实时监听，因为组件的初始化是不可逆的。 typs 配置定义目录，用于开发者自定义配置，框架配置已在各个功能包中定义，无需重复定义 vars 配置实例化目录，用于开发者实例化配置 vars/AmqpConf.go RabbitMQ配置，定义文件在 cAmqp 包中 vars/CommandConf.go 任务指令配置，定义文件在 cCommand 包中 vars/ConfigCenterConf.go 配置中心配置，定义文件在 cConfig 包中 vars/DatabaseConf.go 数据库配置，定义文件在 cDB 包中 vars/KafkaConf.go kafka配置，定义文件在 cKafka 包中 vars/LogConf.go 日志配置，定义文件在 cLog 包中 vars/RedisConf.go redis配置，定义文件在 cRedis 包中 vars/RouteConf.go 路由配置，定义文件在 cServer 包中 vars/RpcConf.go rpc配置，定义文件在 cRpc 包中 vars/ServerConf.go 应用服务配置，定义文件在 cServer 包中 2. 自定义配置 2.1 配置说明 自定义配置必须继承 cConfig.ConfigInterface 自定义配置必须注入容器后才能使用到配置中心相关功能 2.2 csingo 创建配置 使用 csingo 指令自定义配置，会在 config/typs 目录中创建配置结构定义文件，在 config/vars 目录中创建配置变量定义文件，并自动注入到容器中 csingo config::create --name=TestConf 2.3 手动创建配置 config/typs 目录创建 TestConf.go 文件，定义配置具体结构 package typs // TestConf 自定义配置结构体 type TestConf {} // ConfigName 继承 cConfig.ConfigInterface，用于读取配置 func (i *TestConf) ConfigName() string { return \"TestConf\" } config/vars 目录中 TestConf.go 文件，实例化配置 package vars import ( \"demo/config/typs\" ) var TestConfig = &typs.TestConf{} autoload/Config.go 文件添加容器注入 package autoload import ( \"demo/config/vars\" \"gitee.com/csingo/cServer\" ) func InjectConf() { cServer.Inject(vars.LogConfig) cServer.Inject(vars.ConfigCenterConfig) cServer.Inject(vars.DatabaseConfig) cServer.Inject(vars.CommandConfig) cServer.Inject(vars.RouteConfig) cServer.Inject(vars.RpcConfig) cServer.Inject(vars.ServerConfig) cServer.Inject(vars.TestConfig) } "},"csingo/2 快速入门/2.4 容器注入.html":{"url":"csingo/2 快速入门/2.4 容器注入.html","title":"2.4 容器注入","keywords":"","body":"容器注入 1. 简介 容器是一个用于管理类依赖和执行依赖注入的强大工具。实际上可以理解为单例管理池，在整个应用中，对容器内的对象进行 get / set 操作，其实都是对在同一个对象进行操作。 在 csingo 中，使用了自己定义的一套容器规则，只有 csingo 内置的 interface 实现才会被注入到容器当中，如果开发者需要使用到容器相关的特性，则需要手动注入。 2. autoload 在 csingo 框架中，存在一个 autoload，该目录原则上是不建议开发者进行修改的。此目录的作用是把继承框架内置interface的实体自动注入容器。 该目录内容只有在启动程序时，进行实体注入，后续不会重复执行。 autoload 目录中的内容，在使用 csingo 指令创建文件时会自动写入。实现了自动注入的interface如下： config command controller validator middleware service domain 2.1 文件说明 Loader.go 全局加载器，用于引入各模块自动加载方法调用 Config.go 配置加载器，加载config目录中的配置 Command.go 任务命令加载器，加载所有应用的Command Controller.go 控制器加载器，加载所有应用的Controller Validator.go 验证器加载器，加载所有应用的Validator Middleware.go 中间件加载器，加载所有应用的Middleware Service.go 应用服务加载器，加载所有应用的Service Domain.go 领域服务加载器，加载所有应用的Domain 3. 注入 & 获取 3.1 注入实体 package autoload import ( \"gitee.com/csingo/cServer\" DemoControllers \"cxy/app/demo/controller\" ) func InjectController() { cServer.Inject(&DemoControllers.HelloController{}) } 3.2 获取实体 package main import ( \"gitee.com/csingo/cServer\" ) func main() { cServer.GetInstance(\"cxy/app/demo/controller/HelloController\") } 注入容器的实体，会生成一个唯一标识，当唯一标识冲突时，实体会被覆盖，所有在使用注入功能时，需要注意避免重复，否则会产生变量逃逸导致内存回收效率降低。 唯一标识(index)生成规则如下： name := reflect.TypeOf(instance).Elem().Name() path := reflect.TypeOf(instance).Elem().PkgPath() index := path + \"/\" + name "},"csingo/2 快速入门/2.5 协程上下文.html":{"url":"csingo/2 快速入门/2.5 协程上下文.html","title":"2.5 协程上下文","keywords":"","body":""},"csingo/2 快速入门/2.6 Proto使用技巧.html":{"url":"csingo/2 快速入门/2.6 Proto使用技巧.html","title":"2.6 Proto使用技巧","keywords":"","body":"Proto使用技巧 1. 优点 可自动生成代码 兼容GRPC，csingo 当前只支持 HTTP-RPC，后续会逐步升级支持GRPC协议 csingo 框架中提供了 cProto 包，用于扩展当前 proto 功能 enum 类型增加 Desc 以及 Error 方法，用于获取常量注释 message 字段增加类型替换功能，用于复杂数据结构的定义和替换 service 增加 http-rpc 服务端和客户端功能 2. 缺点 需要提前编辑好 proto 文件才能自动生成代码 3. 使用示例 3.1 定义service 具体定义方法参考 应用服务 章节 syntax = \"proto3\"; option go_package = \"../demo\"; package demo; import \"demo/Message.proto\"; service HelloService { rpc Hello(HelloServiceHelloReq) returns (HelloServiceHelloRsp); } 3.2 定义结构体 syntax = \"proto3\"; option go_package = \"../demo\"; package demo; message HelloServiceHelloReq { string name = 1; // } message HelloServiceHelloRsp { string name = 1; } enum DemoError { DemoError_Nil = 0; DemoError_NotFound = 100001; // } enum DemoName { DemoName_Default = 0; // DemoName_Demo = 1; // } 用于重定义数据类型 用于定义常量继承 error 接口，实现 Error() 方法 用于定义常量描述信息，实现 Desc() 方法 3.2 生成代码 csingo app::service --app=demo [--protoPath=] 自动生成的代码存放在 base/demo 目录中，其中包含 HTTP-RPC 的服务端及客户端代码，以及 proto 结构体定义代码 "},"csingo/3 基础功能/3.1 路由.html":{"url":"csingo/3 基础功能/3.1 路由.html","title":"3.1 路由","keywords":"","body":"路由 1. 简介 配置文件位于 config/RouteConf.go 文件中 加载文件位于 autoload/Config.go 文件中 支持路由分组 支持无限层级的路由嵌套 支持设置中间件 支持混合的请求方法，即可定义接口同时接收 POST / GET 等请求 2. 路由配置，config/RouteConf.go 当 Path 为空时，代表路由组，此时不应设置 Method, Controller 和 Function，若设置了则会被处理 中间件区分前置中间件和后置中间件，前置中间件在进入 Controller 前调用，后置中间件在完成 Controller 后调用；中间件配置的顺序就是执行顺序 Method 为http请求方式，仅支持 restful 的请求方式： GET / POST / PUT / DELETE / OPTIONS / PATCH / HEAD / Any Method 重复定义会导致请求被处理多次，所以使用时应注意避免重复定义。 路由配置可使用配置中心，但配置中心变更后需要重启服务。（后续版本优化为动态加载路由） package vars import ( \"gitee.com/csingo/cServer\" ) var RouteConfig = &cServer.RouteConf{ Path: \"\", Method: \"\", Controller: \"\", Function: \"\", Middlewares: &cServer.RouteConf_Middlewares{ Prefix: []*cServer.RouteConf_Middleware{ {App: \"demo\", Name: \"HelloMiddleware\"}, }, Surfix: []*cServer.RouteConf_Middleware{}, }, Routes: []*cServer.RouteConf{ {Path: \"/rpc/call\", Method: []string{\"POST\"}, App: \"csingo\", Controller: \"RpcController\", Function: \"Handler\"}, {Path: \"/ping\", Method: []string{\"GET\", \"POST\"}, App: \"demo\", Controller: \"HelloController\", Function: \"Say\"}, }, } 2.1 路由定义 package cServer type RouteConf struct { Path string `json:\"path\"` Method string `json:\"method\"` App string `json:\"app\"` Controller string `json:\"controller\"` Function string `json:\"function\"` Middlewares *RouteConf_Middlewares `json:\"middlewares\"` Routes []*RouteConf `json:\"routes\"` } type RouteConf_Middlewares struct { Prefix []*RouteConf_Middleware `json:\"prefix\"` Surfix []*RouteConf_Middleware `json:\"surfix\"` } type RouteConf_Middleware struct { App string `json:\"app\"` Name string `json:\"name\"` } func (i *RouteConf) ConfigName() string { return \"RouteConf\" } 2.2 路由解析 路由解析按照数组顺序进行 当路由设置了多个Method，按照Method顺序进行解析 路由解析在所有配置完成加载之后，HTTP 服务启动之前 2.3 路由挂载 路由挂载位于 HTTP 服务启动时进行，对解析好的路由进行挂载写入 单个路由中的执行顺序为：接收请求 -> 匹配路由 -> 执行前置中间件 -> 执行控制器 -> 执行后置中间件 -> 返回结果 中间件和控制器之间的内容传递只能通过协程上下文 路由挂载成功后无法修改或删除路由，只能新增。修改或删除只能通过重新创建 HTTP 服务实现。 "},"csingo/3 基础功能/3.2 控制器.html":{"url":"csingo/3 基础功能/3.2 控制器.html","title":"3.2 控制器","keywords":"","body":"控制器 使用工具创建控制器 在 app/demo/controller 目录创建 TestController.go csingo app::controller --app=demo --name=TestController 自定义创建控制器 定义控制器，在 app/demo/controller 目录中定义 HelloController.go 文件 package controller import ( \"gitee.com/csingo/cError\" \"gitee.com/csingo/cResponse\" \"github.com/gin-gonic/gin\" ) type HelloController struct{} func (i *HelloController) ControllerName() (app, name string) { return \"demo\", \"HelloController\" } 注入容器，在 autoload/Controller.go 文件中添加控制器实例 package autoload import ( \"gitee.com/csingo/cServer\" DemoControllers \"gitee.com/csingo/example/app/demo/controller\" ) func InjectController() { cServer.Inject(&DemoControllers.HelloController{}) } "},"csingo/3 基础功能/3.3 验证器.html":{"url":"csingo/3 基础功能/3.3 验证器.html","title":"3.3 验证器","keywords":"","body":"验证器 创建验证器 在 app/demo/validator 目录创建 TestValidator.go csingo app::validator --app=demo --name=TestValidator 使用例子 package cValidator import ( \"gitee.com/csingo/cValidator/rules\" \"log\" \"testing\" ) type A struct { AAA string `json:\"aaa\"` BB *B `json:\"bb\"` } type B struct { BBB string `json:\"bbb\"` CC *C `json:\"cc\"` } type C struct { CCC string `json:\"ccc\"` DD []*D `json:\"dd\"` } type D struct { DDD string `json:\"ddd\"` AA *A `json:\"aa\"` } var o = map[string]*A{ \"m\": &A{ AAA: \"oa\", BB: &B{ BBB: \"ob\", CC: &C{ CCC: \"oc\", DD: []*D{ &D{DDD: \"od1\"}, &D{DDD: \"od2\"}, }, }, }, }, } type TestValidator struct{} func (i *TestValidator) ValidatorName() (app, name string) { return \"test\", \"TestValidator\" } func (i *TestValidator) Rules() map[string][]*rules.ValidatorRules { return map[string][]*rules.ValidatorRules{ \"test\": { { Field: \"m.BB.CC.DD.*.DDD\", Rules: []*rules.ValidatorRule{{Name: \"required\", Message: \"必须\"}}, }, }, } } func TestInject(t *testing.T) { Load() Inject(&TestValidator{}) err := Validate([]*Validator{ {App: \"test\", Name: \"TestValidator\", Scene: \"test\"}, }, o) log.Println(err) } 规则列表 required "},"csingo/3 基础功能/3.4 中间件.html":{"url":"csingo/3 基础功能/3.4 中间件.html","title":"3.4 中间件","keywords":"","body":"中间件 类型 前置中间件, 在调用 controller 前调用 后置中间件，在调用 controller 后调用 创建中间件 在 app/demo/middleware 目录创建 TestMiddleware.go csingo app::middleware --app=demo --name=TestMiddleware "},"csingo/3 基础功能/3.5 应用服务.html":{"url":"csingo/3 基础功能/3.5 应用服务.html","title":"3.5 应用服务","keywords":"","body":"应用服务 借鉴 DDD 领域驱动设计，独立出一层应用服务。用于应用服务相互调用，以及调用本领域的领域服务。跨领域调用，只能经过应用服务进行。 1. 功能说明 service 中可调用其他 app 的 service，本 app 的 repository / model 。 service 可被 controller 和 command 中调用。 service 应该由 proto 生成，因为在其他程序中调用时，需要使用 proto 生成 sdk 由 proto 生成的 service 方法，只会不断叠加，不会进行删减 2. 创建步骤 2.1 定义 proto 建议 service 定义 和 message 定义区分开单独的两个文件 建议每个 service 单独一个 proto 文件 HelloService.proto syntax = \"proto3\"; option go_package = \"../demo\"; package demo; import \"demo/Message.proto\"; service HelloService { rpc Hello(HelloServiceHelloReq) returns (HelloServiceHelloRsp); } Message.proto syntax = \"proto3\"; option go_package = \"../demo\"; package demo; message HelloServiceHelloReq { string name = 1; } message HelloServiceHelloRsp { string name = 1; } 2.2 生成 service csingo app::service --app=demo [--protoPath=] 执行指令后，在 base/demo 生成相关sdk，在 app/demo/service 生成 HelloService.go，在 autoload/Service.go 注入 HelloServiceHTTPServer 。 sdk目录结构 base/demo ├── HelloService.pb.go // proto 生成的service定义文件 ├── HelloServiceHttpClient.go // 框架自动生成的sdk客户端 ├── HelloServiceHttpServer.go // 框架自定生成的HTTP服务端 └── Message.pb.go // proto 生成的message定义文件 app/demo/service/HelloService.go package service import ( \"example/base/demo\" \"github.com/gin-gonic/gin\" ) type HelloService struct { demo.HelloServiceHTTPServer } func (i *HelloService) Hello(ctx *gin.Context, req *demo.HelloServiceHelloReq) (rsp *demo.HelloServiceHelloRsp, err error) { return nil, nil } autoload/Service.go package autoload import ( \"gitee.com/csingo/cServer\" DemoServices \"example/app/demo/service\" ) func InjectService() { cServer.Inject(&DemoServices.HelloService{}) } 2.3 调用 service package controller import ( \"example/app/demo/service\" \"example/base/demo\" \"github.com/gin-gonic/gin\" ) type HelloController struct{} func (i *HelloController) ControllerName() (app, name string) { return \"demo\", \"HelloController\" } func (i *HelloController) Say(ctx *gin.Context) (int, interface{}) { rsp, _ := (&service.HelloService{}).Hello(ctx, &demo.HelloServiceHelloReq{Name: \"cxy\"}) return 0, rsp } "},"csingo/3 基础功能/3.6 领域服务.html":{"url":"csingo/3 基础功能/3.6 领域服务.html","title":"3.6 领域服务","keywords":"","body":"领域服务 创建领域服务 在 app/demo/domain 目录创建 TestDomain.go csingo app::domain --app=demo --name=TestDomain "},"csingo/3 基础功能/3.7 模型.html":{"url":"csingo/3 基础功能/3.7 模型.html","title":"3.7 模型","keywords":"","body":"模型 "},"csingo/3 基础功能/3.8 任务命令.html":{"url":"csingo/3 基础功能/3.8 任务命令.html","title":"3.8 任务命令","keywords":"","body":"任务命令 任务命令会在应用启动时先于 HTTP 服务启动，可设置常驻任务和定时任务。 可执行应用的初始化操作，队列操作等等 任务执行已做了panic捕获处理，一般情况下，任务执行panic不应该导致程序终止运行 任务命令类型 定时任务 常驻任务 任务命令模式 异步串行模式（CommandMode_Single） 异步并行模式（CommandMode_Multi） 同步阻塞模式（CommandMode_Sync） 创建任务命令 在 app/demo/command 目录添加 TestCommand.go csingo app::command --app=demo --name=TestCommand 配置任务命令 配置内容 package vars import \"gitee.com/csingo/cCommand\" var CommandConfig = &cCommand.CommandConf{ Enable: true, Commands: []*cCommand.CommandConf_Command{ {Mode: cCommand.CommandMode_Single, Wait: 0, Try: 1, Cron: \"* * * * * *\", App: \"demo\", Command: \"HelloCommand\", Method: \"Say\", Options: []string{\"cxy\"}}, }, } 参数说明 Mode 任务模式cCommand.CommandMode_Single 异步串行模式cCommand.CommandMode_Multi 异步并行模式 cCommand.CommandMode_Synci 同步阻塞模式 Wait 延时时长，单位秒。等待一定时间后开始执行。注意是不会阻塞其他任务和服务的，除非是同步阻塞模式 Try 执行次数。try > 0 时，Cron 配置不生效，执行完指定次数后会自动销毁任务；try = 0 时，无限循环执行 Cron 定时配置，参考linux中的crontab，可精确到秒。当 Try = 0 时，该配置有效 App 指定应用文件夹 Command 指定执行的Command Method 指定执行的方法 Options 指定执行方法的参数，注意严格按照方法定义的参数顺序进行传参，每个都参数必须是字符串类型 "},"csingo/3 基础功能/3.9 请求.html":{"url":"csingo/3 基础功能/3.9 请求.html","title":"3.9 请求","keywords":"","body":"请求 "},"csingo/3 基础功能/3.10 响应.html":{"url":"csingo/3 基础功能/3.10 响应.html","title":"3.10 响应","keywords":"","body":"响应 "},"csingo/3 基础功能/3.11 异常.html":{"url":"csingo/3 基础功能/3.11 异常.html","title":"3.11 异常","keywords":"","body":"异常 "},"csingo/3 基础功能/3.12 日志.html":{"url":"csingo/3 基础功能/3.12 日志.html","title":"3.12 日志","keywords":"","body":"日志 "},"csingo/4 组件库/4.1 配置中心.html":{"url":"csingo/4 组件库/4.1 配置中心.html","title":"4.1 配置中心","keywords":"","body":""},"csingo/4 组件库/4.2 Proto.html":{"url":"csingo/4 组件库/4.2 Proto.html","title":"4.2 Proto","keywords":"","body":""},"csingo/4 组件库/4.3 Redis.html":{"url":"csingo/4 组件库/4.3 Redis.html","title":"4.3 Redis","keywords":"","body":""},"csingo/4 组件库/4.4 Kafka.html":{"url":"csingo/4 组件库/4.4 Kafka.html","title":"4.4 Kafka","keywords":"","body":""},"csingo/5 微服务/5.1 HTTP-RPC.html":{"url":"csingo/5 微服务/5.1 HTTP-RPC.html","title":"5.1 HTTP RPC","keywords":"","body":""},"csingo/5 微服务/5.2 应用SDK.html":{"url":"csingo/5 微服务/5.2 应用SDK.html","title":"5.2 应用SDK","keywords":"","body":""}}