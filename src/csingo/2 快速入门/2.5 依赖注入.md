# 依赖注入

## 1. 简介
依赖注入（Dependency Injection，简称DI）是一种软件设计模式，它的核心理念是将对象所依赖的外部组件从对象内部移至对象外部进行管理与装配。在传统的编程方式中，一个类如果需要另一个类的服务，通常会自己创建这个服务的实例。而依赖注入则通过某种方式（如构造器、setter方法或注解等），由外部容器负责为依赖类提供所需服务的实例。<br>

这种设计模式是实现控制反转（Inversion of Control, IoC）的一种具体手段，IoC是指程序的控制流由传统的方式（即对象主动创建和管理依赖）反转为由容器或框架来控制对象的生命周期及相互间的依赖关系。

## 2. 作用
通过依赖注入，可以实现以下目标：

- **松耦合**：减少类之间的直接依赖关系，使得模块更易于独立开发、测试和重用。
- **可测试性增强**：由于依赖项可以从外部注入模拟对象（mock objects），因此可以在单元测试中更容易地隔离被测对象。
- **配置灵活性**：依赖的对象可以通过配置文件或者运行时环境动态调整，无需修改代码就能改变系统的行为。

## 3. 使用

### 3.1 说明
- 依赖注入只作用于已经注入容器的实体，即注入容器的实体才能注入依赖和被注入依赖。
- 被注入的属性，必须是开放的，即首字母大写。
- 被注入的属性，必须定义为引用类型，实体类型无法注入，即 **\*** 开头

## 3.2 详情
```golang
type HelloController struct {
	Svc *service.HelloService
}

func (i *HelloController) Hello(ctx *gin.Context) (err error) {
	_, err := i.Svc.Hello(ctx, nil)
	return
}
```

如上，**_HelloController_** 和 **_HelloService_** 必须都已经注入到容器中，才能在 **_HelloController_** 中注入 **_HelloService_**，任意一个不在容器中，都会导致依赖注入失败。<br>
程序启动，会自动完成容器内各实体的依赖注入，无需手动干预。<br>
使用只需要直接引用即可，无需手动实例化。